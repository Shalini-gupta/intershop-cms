{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///external \"jest-matcher-utils\"","webpack:///external \"rxjs\"","webpack:///external \"jest-diff\"","webpack:///external \"rxjs/testing\"","webpack:///external \"expect/build/jasmineUtils\"","webpack:///./src/marbles-glossary.ts","webpack:///./src/notification-event.ts","webpack:///./src/notification-kind.ts","webpack:///./src/marblizer.ts","webpack:///./src/jest/custom-matchers.ts","webpack:///./src/rxjs/assert-deep-equal.ts","webpack:///./src/rxjs/scheduler.ts","webpack:///./src/rxjs/cold-observable.ts","webpack:///./src/rxjs/hot-observable.ts","webpack:///./src/rxjs/strip-alignment-chars.ts","webpack:///./index.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","jest","matcher","utils","rxjs","diff","testing","expect","build","jasmineUtils","MarblesGlossary","NotificationEvent","start","marbles","this","length","ValueLiteral","NotificationKindChars","N","C","Completion","E","Error","messages","emissions","getNotificationEvents","prevEndFrame","end","TimeFrame","repeat","logs","map","log","marblizeLogEntry","subscribedFrame","Subscription","unsubscribedFrame","Unsubscription","logPoint","symbol","Infinity","framesToEmissions","reduce","result","message","frame","extractMarble","events","keys","encloseGroupEvents","marble","notification","kind","forEach","event","GroupStart","GroupEnd","isCharacter","undefined","JSON","stringify","customTestMatchers","actual","expected","actualMarble","expectedMarble","every","filter","canMarblize","marblize","pass","diffString","expand","actualMarbleArray","marblizeSubscriptions","expectedMarbleArray","includes","subscriptionsPass","assertDeepEqual","actualIsSubscriptionsAndExpectedIsEmpty","expectedIsSubscriptionLogArray","toBeNotifications","toBeSubscriptions","toHaveEmptySubscriptions","extend","instance","observable","outerFrame","materializeInnerObservable","values","error","super","source","createColdObservable","subscriptions","createHotObservable","stripAlignmentChars","replace","hot","cold","time","createTime","dummyResult","sanitizedMarbles","Array","isArray","expectSubscriptions","getSubscriptions","toBe","toHaveNoSubscriptions","toBeObservable","expectObservable","toBeMarble","func","flushTests","ready","onFlush","push","beforeEach","init","afterEach","flush","shift","reset"],"mappings":"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","file":"index.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 5);\n","module.exports = jest-matcher-utils;","module.exports = rxjs;","module.exports = jest-diff;","module.exports = rxjs/testing;","module.exports = expect/build/jasmineUtils;","export enum MarblesGlossary {\n  Completion = '|',\n  Error = '#',\n  TimeFrame = '-',\n  Subscription = '^',\n  Unsubscription = '!',\n  GroupStart = '(',\n  GroupEnd = ')',\n}\n","export class NotificationEvent {\n  marbles = '';\n  constructor(public start: number) {}\n  get end(): number {\n    return this.start + this.marbles.length;\n  }\n}\n","import { MarblesGlossary } from './marbles-glossary';\nexport const ValueLiteral = {};\n\nexport const NotificationKindChars = {\n  N: ValueLiteral,\n  C: MarblesGlossary.Completion,\n  E: MarblesGlossary.Error,\n};\n","import { SubscriptionLog, TestMessages } from './rxjs/types';\nimport { MarblesGlossary } from './marbles-glossary';\nimport { NotificationEvent } from './notification-event';\nimport { NotificationKindChars, ValueLiteral } from './notification-kind';\n\nconst frameStep = 10;\n\nexport class Marblizer {\n  public static marblize(messages: TestMessages): string {\n    const emissions = Marblizer.getNotificationEvents(messages);\n    let marbles = '';\n    for (let i = 0, prevEndFrame = 0; i < emissions.length; prevEndFrame = emissions[i].end, i++) {\n      marbles = `${marbles}${MarblesGlossary.TimeFrame.repeat(emissions[i].start - prevEndFrame) +\n        emissions[i].marbles}`;\n    }\n    return marbles;\n  }\n\n  public static marblizeSubscriptions(logs: SubscriptionLog[]): string[] {\n    return logs.map(\n      log =>\n        this.marblizeLogEntry(log.subscribedFrame / frameStep, MarblesGlossary.Subscription) +\n        this.marblizeLogEntry(\n          (log.unsubscribedFrame - log.subscribedFrame) / frameStep - 1,\n          MarblesGlossary.Unsubscription\n        )\n    );\n  }\n\n  private static marblizeLogEntry(logPoint: number, symbol: string): string {\n    if (logPoint !== Infinity) {\n      return MarblesGlossary.TimeFrame.repeat(logPoint) + symbol;\n    } else {\n      return '';\n    }\n  }\n\n  private static getNotificationEvents(messages: TestMessages) {\n    const framesToEmissions = messages.reduce<{ [frame: number]: NotificationEvent }>((result, message) => {\n      if (!result[message.frame]) {\n        result[message.frame] = new NotificationEvent(message.frame / frameStep);\n      }\n      const event = result[message.frame];\n      event.marbles += Marblizer.extractMarble(message);\n      return result;\n    }, {});\n\n    const events = Object.keys(framesToEmissions).map<NotificationEvent>(frame => framesToEmissions[frame]);\n\n    Marblizer.encloseGroupEvents(events);\n    return events;\n  }\n\n  private static extractMarble(message: TestMessages[0]) {\n    let marble = NotificationKindChars[message.notification.kind];\n    if (marble === ValueLiteral) marble = (message.notification as any).value;\n    return marble;\n  }\n\n  private static encloseGroupEvents(events: NotificationEvent[]) {\n    events.forEach(event => {\n      if (event.marbles.length > 1) {\n        event.marbles = `${MarblesGlossary.GroupStart}${event.marbles}${MarblesGlossary.GroupEnd}`;\n      }\n    });\n  }\n}\n","import { equals } from 'expect/build/jasmineUtils';\nimport { diff } from 'jest-diff';\nimport { matcherHint, printExpected, printReceived } from 'jest-matcher-utils';\nimport { TestMessages, SubscriptionLog } from '../rxjs/types';\nimport { Marblizer } from '../marblizer';\n\nfunction canMarblize(...messages: TestMessages[]) {\n  return messages.every(message => message.filter(({ notification: { kind } }) => kind === 'N').every(isCharacter));\n}\n\nfunction isCharacter({ notification }: TestMessages[0]): boolean {\n  const value = (notification as any).value;\n  return (\n    (typeof value === 'string' && value.length === 1) || (value !== undefined && JSON.stringify(value).length === 1)\n  );\n}\n\nexport const customTestMatchers = {\n  toBeNotifications(actual: TestMessages, expected: TestMessages) {\n    let actualMarble: string | TestMessages = actual;\n    let expectedMarble: string | TestMessages = expected;\n    if (canMarblize(actual, expected)) {\n      actualMarble = Marblizer.marblize(actual);\n      expectedMarble = Marblizer.marblize(expected);\n    }\n\n    const pass = equals(actualMarble, expectedMarble);\n\n    const message = pass\n      ? () =>\n          matcherHint('.not.toBeNotifications') +\n          '\\n\\n' +\n          `Expected notifications to not be:\\n` +\n          `  ${printExpected(expectedMarble)}\\n` +\n          `But got:\\n` +\n          `  ${printReceived(actualMarble)}`\n      : () => {\n          const diffString = diff(expectedMarble, actualMarble, {\n            expand: true,\n          });\n          return (\n            matcherHint('.toBeNotifications') +\n            '\\n\\n' +\n            `Expected notifications to be:\\n` +\n            `  ${printExpected(expectedMarble)}\\n` +\n            `But got:\\n` +\n            `  ${printReceived(actualMarble)}` +\n            (diffString ? `\\n\\nDifference:\\n\\n${diffString}` : '')\n          );\n        };\n\n    return { actual, message, pass };\n  },\n\n  toBeSubscriptions(actual: SubscriptionLog[], expected: SubscriptionLog[]) {\n    const actualMarbleArray = Marblizer.marblizeSubscriptions(actual);\n    const expectedMarbleArray = Marblizer.marblizeSubscriptions(expected);\n\n    const pass = subscriptionsPass(actualMarbleArray, expectedMarbleArray);\n    const message = pass\n      ? () =>\n          matcherHint('.not.toHaveSubscriptions') +\n          '\\n\\n' +\n          `Expected observable to not have the following subscription points:\\n` +\n          `  ${printExpected(expectedMarbleArray)}\\n` +\n          `But got:\\n` +\n          `  ${printReceived(actualMarbleArray)}`\n      : () => {\n          const diffString = diff(expectedMarbleArray, actualMarbleArray, {\n            expand: true,\n          });\n          return (\n            matcherHint('.toHaveSubscriptions') +\n            '\\n\\n' +\n            `Expected observable to have the following subscription points:\\n` +\n            `  ${printExpected(expectedMarbleArray)}\\n` +\n            `But got:\\n` +\n            `  ${printReceived(actualMarbleArray)}` +\n            (diffString ? `\\n\\nDifference:\\n\\n${diffString}` : '')\n          );\n        };\n\n    return { actual, message, pass };\n  },\n\n  toHaveEmptySubscriptions(actual: SubscriptionLog[] | undefined) {\n    const pass = !(actual && actual.length > 0);\n    let marbles: string[];\n    if (actual && actual.length > 0) {\n      marbles = Marblizer.marblizeSubscriptions(actual);\n    }\n    const message = pass\n      ? () =>\n          matcherHint('.not.toHaveNoSubscriptions') +\n          '\\n\\n' +\n          `Expected observable to have at least one subscription point, but got nothing` +\n          printReceived('')\n      : () =>\n          matcherHint('.toHaveNoSubscriptions') +\n          '\\n\\n' +\n          `Expected observable to have no subscription points\\n` +\n          `But got:\\n` +\n          `  ${printReceived(marbles)}\\n\\n`;\n    return { actual, message, pass };\n  },\n};\n\nfunction subscriptionsPass(actualMarbleArray: string[], expectedMarbleArray: string[]): boolean {\n  if (actualMarbleArray.length !== expectedMarbleArray.length) {\n    return false;\n  }\n  let pass = true;\n  for (const actualMarble of actualMarbleArray) {\n    if (!expectedMarbleArray.includes(actualMarble)) {\n      pass = false;\n      break;\n    }\n  }\n  return pass;\n}\n\ndeclare global {\n  namespace jest {\n    interface Matchers<R, T> {\n      toBeNotifications(notifications: TestMessages): void;\n\n      toBeSubscriptions(subscriptions: SubscriptionLog[]): void;\n\n      toHaveEmptySubscriptions(): void;\n    }\n  }\n}\n\nexpect.extend(customTestMatchers);\n","import { TestMessages, SubscriptionLog } from '../rxjs/types';\n\nimport '../jest/custom-matchers';\n\nexport type MessageOrSubscription = TestMessages | SubscriptionLog[];\n\nfunction expectedIsSubscriptionLogArray(\n  actual: MessageOrSubscription,\n  expected: MessageOrSubscription\n): expected is SubscriptionLog[] {\n  return (\n    (actual.length === 0 && expected.length === 0) ||\n    (expected.length !== 0 && (expected[0] as any).subscribedFrame !== undefined)\n  );\n}\n\nfunction actualIsSubscriptionsAndExpectedIsEmpty(\n  actual: MessageOrSubscription,\n  expected: MessageOrSubscription\n): actual is SubscriptionLog[] {\n  return expected.length === 0 && actual.length !== 0 && (actual[0] as any).subscribedFrame !== undefined;\n}\n\nexport function assertDeepEqual(actual: MessageOrSubscription, expected: MessageOrSubscription) {\n  if (!expected) return;\n  if (actualIsSubscriptionsAndExpectedIsEmpty(actual, expected)) {\n    expect(actual).toHaveEmptySubscriptions();\n  } else if (expectedIsSubscriptionLogArray(actual, expected)) {\n    expect(actual).toBeSubscriptions(expected);\n  } else {\n    expect(actual).toBeNotifications(expected);\n  }\n}\n","import { Observable } from 'rxjs';\nimport { TestMessages } from './types';\nimport { TestScheduler } from 'rxjs/testing';\n\nimport { assertDeepEqual } from './assert-deep-equal';\n\nexport class Scheduler {\n  public static instance: TestScheduler | null;\n\n  public static init(): void {\n    Scheduler.instance = new TestScheduler(assertDeepEqual);\n  }\n\n  public static get(): TestScheduler {\n    if (Scheduler.instance) {\n      return Scheduler.instance;\n    }\n    throw new Error('Scheduler is not initialized');\n  }\n\n  public static reset(): void {\n    Scheduler.instance = null;\n  }\n\n  public static materializeInnerObservable(observable: Observable<any>, outerFrame: number): TestMessages {\n    const scheduler = Scheduler.get();\n    // @ts-ignore\n    return scheduler.materializeInnerObservable(observable, outerFrame);\n  }\n}\n","import { Observable } from 'rxjs';\nimport { TestScheduler } from 'rxjs/testing';\nimport { SubscriptionLog } from '../rxjs/types';\n\nimport { Scheduler } from './scheduler';\n\nexport class ColdObservable extends Observable<any> {\n  source: ReturnType<TestScheduler['createColdObservable']>;\n  constructor(public marbles: string, public values?: Record<string, any>, public error?: any) {\n    super();\n\n    this.source = Scheduler.get().createColdObservable(marbles, values, error);\n  }\n\n  getSubscriptions(): SubscriptionLog[] {\n    return this.source.subscriptions;\n  }\n}\n","import { Observable } from 'rxjs';\nimport { TestScheduler } from 'rxjs/testing';\nimport { SubscriptionLog } from '../rxjs/types';\n\nimport { Scheduler } from './scheduler';\n\nexport class HotObservable extends Observable<any> {\n  source: ReturnType<TestScheduler['createHotObservable']>;\n  constructor(public marbles: string, public values?: Record<string, any>, public error?: any) {\n    super();\n\n    this.source = Scheduler.get().createHotObservable(marbles, values, error);\n  }\n\n  getSubscriptions(): SubscriptionLog[] {\n    return this.source.subscriptions;\n  }\n}\n","export function stripAlignmentChars(marbles: string) {\n  return marbles.replace(/^[ ]+/, '');\n}\n","import { ColdObservable } from './src/rxjs/cold-observable';\nimport { HotObservable } from './src/rxjs/hot-observable';\nimport { Scheduler } from './src/rxjs/scheduler';\nimport { stripAlignmentChars } from './src/rxjs/strip-alignment-chars';\n\nexport type ObservableWithSubscriptions = ColdObservable | HotObservable;\n\nexport { Scheduler } from './src/rxjs/scheduler';\n\ndeclare global {\n  namespace jest {\n    interface Matchers<R, T> {\n      toBeObservable(observable: ObservableWithSubscriptions): void;\n\n      toHaveSubscriptions(marbles: string | string[]): void;\n\n      toHaveNoSubscriptions(): void;\n\n      toBeMarble(marble: string): void;\n\n      toSatisfyOnFlush(func: () => void): void;\n    }\n  }\n}\n\nexport function hot(marbles: string, values?: any, error?: any): HotObservable {\n  return new HotObservable(stripAlignmentChars(marbles), values, error);\n}\n\nexport function cold(marbles: string, values?: any, error?: any): ColdObservable {\n  return new ColdObservable(stripAlignmentChars(marbles), values, error);\n}\n\nexport function time(marbles: string): number {\n  return Scheduler.get().createTime(stripAlignmentChars(marbles));\n}\n\nconst dummyResult = {\n  message: () => '',\n  pass: true\n};\n\nexpect.extend({\n\n  toHaveSubscriptions(actual: ObservableWithSubscriptions, marbles: string | string[]) {\n    const sanitizedMarbles = Array.isArray(marbles) ? marbles.map(stripAlignmentChars) : stripAlignmentChars(marbles);\n    Scheduler.get().expectSubscriptions(actual.getSubscriptions()).toBe(sanitizedMarbles);\n    return dummyResult;\n  },\n\n  toHaveNoSubscriptions(actual: ObservableWithSubscriptions) {\n    Scheduler.get().expectSubscriptions(actual.getSubscriptions()).toBe([]);\n    return dummyResult;\n  },\n\n  toBeObservable(actual, expected: ObservableWithSubscriptions) {\n    Scheduler.get().expectObservable(actual).toBe(expected.marbles, expected.values, expected.error);\n    return dummyResult;\n  },\n\n  toBeMarble(actual: ObservableWithSubscriptions, marbles: string) {\n    Scheduler.get().expectObservable(actual).toBe(stripAlignmentChars(marbles));\n    return dummyResult;\n  },\n\n  toSatisfyOnFlush(actual: ObservableWithSubscriptions, func: () => void) {\n    Scheduler.get().expectObservable(actual);\n    // tslint:disable:no-string-literal\n    const flushTests = Scheduler.get()['flushTests'];\n    flushTests[flushTests.length - 1].ready = true;\n    onFlush.push(func);\n    return dummyResult;\n  }\n});\n\nlet onFlush: (() => void)[] = [];\n\nbeforeEach(() => { Scheduler.init(); onFlush = []; });\nafterEach(() => {\n  Scheduler.get().flush();\n  while (onFlush.length > 0) {\n    // @ts-ignore\n    onFlush.shift()();\n  }\n  Scheduler.reset();\n});\n"],"sourceRoot":""}
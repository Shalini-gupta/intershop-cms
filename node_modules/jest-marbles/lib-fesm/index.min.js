!function(t){var e={};function n(r){if(e[r])return e[r].exports;var i=e[r]={i:r,l:!1,exports:{}};return t[r].call(i.exports,i,i.exports,n),i.l=!0,i.exports}n.m=t,n.c=e,n.d=function(t,e,r){n.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:r})},n.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},n.t=function(t,e){if(1&e&&(t=n(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var i in t)n.d(r,i,function(e){return t[e]}.bind(null,i));return r},n.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return n.d(e,"a",e),e},n.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},n.p="",n(n.s=5)}([function(t,e){t.exports=jest-matcher-utils},function(t,e){t.exports=rxjs},function(t,e){t.exports=jest-diff},function(t,e){t.exports=rxjs/testing},function(t,e){t.exports=expect/build/jasmineUtils},function(t,e,n){t.exports=n(6)},function(t,e,n){"use strict";n.r(e),n.d(e,"Scheduler",(function(){return g})),n.d(e,"hot",(function(){return O})),n.d(e,"cold",(function(){return S})),n.d(e,"time",(function(){return j}));var r,i=n(1),s=n(3),o=n(4),c=n(2),a=n(0);!function(t){t.Completion="|",t.Error="#",t.TimeFrame="-",t.Subscription="^",t.Unsubscription="!",t.GroupStart="(",t.GroupEnd=")"}(r||(r={}));class u{constructor(t){this.start=t,this.marbles=""}get end(){return this.start+this.marbles.length}}const b={},l={N:b,C:r.Completion,E:r.Error};class p{static marblize(t){const e=p.getNotificationEvents(t);let n="";for(let t=0,i=0;t<e.length;i=e[t].end,t++)n=`${n}${r.TimeFrame.repeat(e[t].start-i)+e[t].marbles}`;return n}static marblizeSubscriptions(t){return t.map(t=>this.marblizeLogEntry(t.subscribedFrame/10,r.Subscription)+this.marblizeLogEntry((t.unsubscribedFrame-t.subscribedFrame)/10-1,r.Unsubscription))}static marblizeLogEntry(t,e){return t!==1/0?r.TimeFrame.repeat(t)+e:""}static getNotificationEvents(t){const e=t.reduce((t,e)=>{t[e.frame]||(t[e.frame]=new u(e.frame/10));return t[e.frame].marbles+=p.extractMarble(e),t},{}),n=Object.keys(e).map(t=>e[t]);return p.encloseGroupEvents(n),n}static extractMarble(t){let e=l[t.notification.kind];return e===b&&(e=t.notification.value),e}static encloseGroupEvents(t){t.forEach(t=>{t.marbles.length>1&&(t.marbles=`${r.GroupStart}${t.marbles}${r.GroupEnd}`)})}}function f({notification:t}){const e=t.value;return"string"==typeof e&&1===e.length||void 0!==e&&1===JSON.stringify(e).length}const d={toBeNotifications(t,e){let n=t,r=e;(function(...t){return t.every(t=>t.filter(({notification:{kind:t}})=>"N"===t).every(f))})(t,e)&&(n=p.marblize(t),r=p.marblize(e));const i=Object(o.equals)(n,r);return{actual:t,message:i?()=>Object(a.matcherHint)(".not.toBeNotifications")+"\n\nExpected notifications to not be:\n"+`  ${Object(a.printExpected)(r)}\nBut got:\n  `+Object(a.printReceived)(n):()=>{const t=Object(c.diff)(r,n,{expand:!0});return Object(a.matcherHint)(".toBeNotifications")+"\n\nExpected notifications to be:\n"+`  ${Object(a.printExpected)(r)}\nBut got:\n  `+Object(a.printReceived)(n)+(t?"\n\nDifference:\n\n"+t:"")},pass:i}},toBeSubscriptions(t,e){const n=p.marblizeSubscriptions(t),r=p.marblizeSubscriptions(e),i=function(t,e){if(t.length!==e.length)return!1;let n=!0;for(const r of t)if(!e.includes(r)){n=!1;break}return n}(n,r);return{actual:t,message:i?()=>Object(a.matcherHint)(".not.toHaveSubscriptions")+"\n\nExpected observable to not have the following subscription points:\n"+`  ${Object(a.printExpected)(r)}\nBut got:\n  `+Object(a.printReceived)(n):()=>{const t=Object(c.diff)(r,n,{expand:!0});return Object(a.matcherHint)(".toHaveSubscriptions")+"\n\nExpected observable to have the following subscription points:\n"+`  ${Object(a.printExpected)(r)}\nBut got:\n  `+Object(a.printReceived)(n)+(t?"\n\nDifference:\n\n"+t:"")},pass:i}},toHaveEmptySubscriptions(t){const e=!(t&&t.length>0);let n;t&&t.length>0&&(n=p.marblizeSubscriptions(t));return{actual:t,message:e?()=>Object(a.matcherHint)(".not.toHaveNoSubscriptions")+"\n\nExpected observable to have at least one subscription point, but got nothing"+Object(a.printReceived)(""):()=>Object(a.matcherHint)(".toHaveNoSubscriptions")+"\n\nExpected observable to have no subscription points\nBut got:\n"+`  ${Object(a.printReceived)(n)}\n\n`,pass:e}}};function m(t,e){e&&(!function(t,e){return 0===e.length&&0!==t.length&&void 0!==t[0].subscribedFrame}(t,e)?!function(t,e){return 0===t.length&&0===e.length||0!==e.length&&void 0!==e[0].subscribedFrame}(t,e)?expect(t).toBeNotifications(e):expect(t).toBeSubscriptions(e):expect(t).toHaveEmptySubscriptions())}expect.extend(d);class g{static init(){g.instance=new s.TestScheduler(m)}static get(){if(g.instance)return g.instance;throw new Error("Scheduler is not initialized")}static reset(){g.instance=null}static materializeInnerObservable(t,e){return g.get().materializeInnerObservable(t,e)}}class h extends i.Observable{constructor(t,e,n){super(),this.marbles=t,this.values=e,this.error=n,this.source=g.get().createColdObservable(t,e,n)}getSubscriptions(){return this.source.subscriptions}}class v extends i.Observable{constructor(t,e,n){super(),this.marbles=t,this.values=e,this.error=n,this.source=g.get().createHotObservable(t,e,n)}getSubscriptions(){return this.source.subscriptions}}function x(t){return t.replace(/^[ ]+/,"")}function O(t,e,n){return new v(x(t),e,n)}function S(t,e,n){return new h(x(t),e,n)}function j(t){return g.get().createTime(x(t))}const E={message:()=>"",pass:!0};expect.extend({toHaveSubscriptions(t,e){const n=Array.isArray(e)?e.map(x):x(e);return g.get().expectSubscriptions(t.getSubscriptions()).toBe(n),E},toHaveNoSubscriptions:t=>(g.get().expectSubscriptions(t.getSubscriptions()).toBe([]),E),toBeObservable:(t,e)=>(g.get().expectObservable(t).toBe(e.marbles,e.values,e.error),E),toBeMarble:(t,e)=>(g.get().expectObservable(t).toBe(x(e)),E),toSatisfyOnFlush(t,e){g.get().expectObservable(t);const n=g.get().flushTests;return n[n.length-1].ready=!0,y.push(e),E}});let y=[];beforeEach(()=>{g.init(),y=[]}),afterEach(()=>{for(g.get().flush();y.length>0;)y.shift()();g.reset()})}]);
//# sourceMappingURL=index.min.js.map
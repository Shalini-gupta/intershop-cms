{"version":3,"file":"rx-state.service.d.ts","sources":["rx-state.service.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA","sourcesContent":["import { OnDestroy } from '@angular/core';\r\nimport { Observable, OperatorFunction, Subscribable, Unsubscribable } from 'rxjs';\r\nimport { AccumulationFn } from './cdk';\r\ndeclare type ProjectStateFn<T> = (oldState: T) => Partial<T>;\r\ndeclare type ProjectValueFn<T, K extends keyof T> = (oldState: T) => T[K];\r\ndeclare type ProjectStateReducer<T, V> = (oldState: T, value: V) => Partial<T>;\r\ndeclare type ProjectValueReducer<T, K extends keyof T, V> = (oldState: T, value: V) => T[K];\r\n/**\r\n * @description\r\n * RxState is a light-weight reactive state management service for managing local state in angular.\r\n *\r\n * @example\r\n * Component({\r\n *   selector: 'app-stateful',\r\n *   template: `<div>{{ state$ | async | json }}</div>`,\r\n *   providers: [RxState]\r\n * })\r\n * export class StatefulComponent {\r\n *   readonly state$ = this.state.select();\r\n *\r\n *   constructor(private state: RxState<{ foo: string }>) {}\r\n * }\r\n *\r\n * @docsCategory RxState\r\n * @docsPage RxState\r\n */\r\nexport declare class RxState<T extends object> implements OnDestroy, Subscribable<T> {\r\n    private subscription;\r\n    private accumulator;\r\n    private effectObservable;\r\n    /**\r\n     * @description\r\n     * The unmodified state exposed as `Observable<T>`. It is not shared, distinct or gets replayed.\r\n     * Use the `$` property if you want to read the state without having applied {@link stateful} to it.\r\n     */\r\n    readonly $: Observable<T>;\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor();\r\n    /**\r\n     * @internal\r\n     */\r\n    ngOnDestroy(): void;\r\n    /**\r\n     * @description\r\n     *\r\n     * Allows to customize state accumulation function.\r\n     * This can be helpful to implement deep updates and tackle other immutability problems in a custom way.\r\n     * @example\r\n     *\r\n     * ```typescript\r\n     * const myAccumulator = (state: MyState, slice: Partial<MyState>) => deepCopy(state, slice);\r\n     *\r\n     * this.state.setAccumulator(myAccumulator);\r\n     * ```\r\n     */\r\n    setAccumulator(accumulatorFn: AccumulationFn): void;\r\n    /**\r\n     * @description\r\n     * Read from the state in imperative manner. Returns the state object in its current state.\r\n     *\r\n     * @example\r\n     * const { disabled } = state.get();\r\n     * if (!disabled) {\r\n     *   doStuff();\r\n     * }\r\n     *\r\n     * @return T\r\n     */\r\n    get(): T;\r\n    /**\r\n     * @description\r\n     * Read from the state in imperative manner by providing keys as parameters.\r\n     * Returns the part of state object.\r\n     *\r\n     * @example\r\n     * // Access a single property\r\n     *\r\n     * const bar = state.get('bar');\r\n     *\r\n     * // Access a nested property\r\n     *\r\n     * const foo = state.get('bar', 'foo');\r\n     *\r\n     * @return T | T[K1] | T[K1][K2]\r\n     */\r\n    get<K1 extends keyof T>(k1: K1): T[K1];\r\n    /** @internal **/\r\n    get<K1 extends keyof T, K2 extends keyof T[K1]>(k1: K1, k2: K2): T[K1][K2];\r\n    /** @internal **/\r\n    get<K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2]>(k1: K1, k2: K2, k3: K3): T[K1][K2][K3];\r\n    /** @internal **/\r\n    get<K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2], K4 extends keyof T[K1][K2][K3]>(k1: K1, k2: K2, k3: K3, k4: K4): T[K1][K2][K3][K4];\r\n    /** @internal **/\r\n    get<K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2], K4 extends keyof T[K1][K2][K3], K5 extends keyof T[K1][K2][K3][K4]>(k1: K1, k2: K2, k3: K3, k4: K4, k5: K5): T[K1][K2][K3][K4][K5];\r\n    /** @internal **/\r\n    get<K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2], K4 extends keyof T[K1][K2][K3], K5 extends keyof T[K1][K2][K3][K4], K6 extends keyof T[K1][K2][K3][K4][K5]>(k1: K1, k2: K2, k3: K3, k4: K4, k5: K5, k6: K6): T[K1][K2][K3][K4][K5][K6];\r\n    /**\r\n     * @description\r\n     * Manipulate one or many properties of the state by providing a `Partial<T>` state or a `ProjectionFunction<T>`.\r\n     *\r\n     * @example\r\n     * // Update one or many properties of the state by providing a `Partial<T>`\r\n     *\r\n     * const partialState = {\r\n     *   foo: 'bar',\r\n     *   bar: 5\r\n     * };\r\n     * state.set(partialState);\r\n     *\r\n     * // Update one or many properties of the state by providing a `ProjectionFunction<T>`\r\n     *\r\n     * const reduceFn = oldState => ({\r\n     *   bar: oldState.bar + 5\r\n     * });\r\n     * state.set(reduceFn);\r\n     *\r\n     * @param {Partial<T>|ProjectStateFn<T>} stateOrProjectState\r\n     * @return void\r\n     */\r\n    set(stateOrProjectState: Partial<T> | ProjectStateFn<T>): void;\r\n    /**\r\n     * @description\r\n     * Manipulate a single property of the state by the property name and a `ProjectionFunction<T>`.\r\n     *\r\n     * @example\r\n     * const reduceFn = oldState => oldState.bar + 5;\r\n     * state.set('bar', reduceFn);\r\n     *\r\n     * @param {K} key\r\n     * @param {ProjectValueFn<T, K>} projectSlice\r\n     * @return void\r\n     */\r\n    set<K extends keyof T, O>(key: K, projectSlice: ProjectValueFn<T, K>): void;\r\n    /**\r\n     * @description\r\n     * Connect an `Observable<Partial<T>>` to the state `T`.\r\n     * Any change emitted by the source will get merged into the state.\r\n     * Subscription handling is done automatically.\r\n     *\r\n     * @example\r\n     * const sliceToAdd$ = interval(250).pipe(mapTo({\r\n     *   bar: 5,\r\n     *   foo: 'foo'\r\n     * });\r\n     * state.connect(sliceToAdd$);\r\n     * // every 250ms the properties bar and foo get updated due to the emission of sliceToAdd$\r\n     *\r\n     * // Additionally you can provide a `projectionFunction` to access the current state object and do custom mappings.\r\n     *\r\n     * const sliceToAdd$ = interval(250).pipe(mapTo({\r\n     *   bar: 5,\r\n     *   foo: 'foo'\r\n     * });\r\n     * state.connect(sliceToAdd$, (state, slice) => state.bar += slice.bar);\r\n     * // every 250ms the properties bar and foo get updated due to the emission of sliceToAdd$. Bar will increase by\r\n     * // 5 due to the projectionFunction\r\n     */\r\n    connect(inputOrSlice$: Observable<Partial<T>>): void;\r\n    /**\r\n     * @description\r\n     * Connect an `Observable<V>` to the state `T`.\r\n     * Any change emitted by the source will get forwarded to to project function and merged into the state.\r\n     * Subscription handling is done automatically.\r\n     *\r\n     * You have to provide a `projectionFunction` to access the current state object and do custom mappings.\r\n     *\r\n     * @example\r\n     * const sliceToAdd$ = interval(250);\r\n     * state.connect(sliceToAdd$, (s, v) => ({bar: v}));\r\n     * // every 250ms the property bar get updated due to the emission of sliceToAdd$\r\n     *\r\n     */\r\n    connect<V>(inputOrSlice$: Observable<V>, projectFn: ProjectStateReducer<T, V>): void;\r\n    /**\r\n     *\r\n     * @description\r\n     * Connect an `Observable<T[K]>` source to a specific property `K` in the state `T`. Any emitted change will update\r\n     * this\r\n     * specific property in the state.\r\n     * Subscription handling is done automatically.\r\n     *\r\n     * @example\r\n     * const myTimer$ = interval(250);\r\n     * state.connect('timer', myTimer$);\r\n     * // every 250ms the property timer will get updated\r\n     */\r\n    connect<K extends keyof T>(key: K, slice$: Observable<T[K]>): void;\r\n    /**\r\n     *\r\n     * @description\r\n     * Connect an `Observable<V>` source to a specific property in the state. Additionally you can provide a\r\n     * `projectionFunction` to access the current state object on every emission of your connected `Observable`.\r\n     * Any change emitted by the source will get merged into the state.\r\n     * Subscription handling is done automatically.\r\n     *\r\n     * @example\r\n     * const myTimer$ = interval(250);\r\n     * state.connect('timer', myTimer$, (state, timerChange) => state.timer += timerChange);\r\n     * // every 250ms the property timer will get updated\r\n     */\r\n    connect<K extends keyof T, V>(key: K, input$: Observable<V>, projectSliceFn: ProjectValueReducer<T, K, V>): void;\r\n    /**\r\n     * @description\r\n     * returns the state as cached and distinct `Observable<T>`. This way you don't have to think about **late\r\n     * subscribers**,\r\n     * **multiple subscribers** or **multiple emissions** of the same value\r\n     *\r\n     * @example\r\n     * const state$ = state.select();\r\n     * state$.subscribe(state => doStuff(state));\r\n     *\r\n     * @returns Observable<T>\r\n     */\r\n    select(): Observable<T>;\r\n    /**\r\n     * @description\r\n     * returns the state as cached and distinct `Observable<A>`. Accepts arbitrary\r\n     * [rxjs operators](https://rxjs-dev.firebaseapp.com/guide/operators) to enrich the selection with reactive composition.\r\n     *\r\n     * @example\r\n     * const profilePicture$ = state.select(\r\n     *  pluck('profilePicture'),\r\n     *  switchMap(profilePicture => mapImageAsync(profilePicture))\r\n     * );\r\n     * @param op { OperatorFunction<T, A> }\r\n     * @returns Observable<A>\r\n     */\r\n    select<A = T>(op: OperatorFunction<T, A>): Observable<A>;\r\n    /**\r\n     * @internal\r\n     */\r\n    select<A = T, B = A>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>): Observable<B>;\r\n    /**\r\n     * @internal\r\n     */\r\n    select<A = T, B = A, C = B>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>): Observable<C>;\r\n    /**\r\n     * @internal\r\n     */\r\n    select<A = T, B = A, C = B, D = C>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>): Observable<D>;\r\n    /**\r\n     * @internal\r\n     */\r\n    select<A = T, B = A, C = B, D = C, E = D>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>): Observable<E>;\r\n    /**\r\n     * @description\r\n     * Access a single property of the state by providing keys.\r\n     * Returns a single property of the state as cached and distinct `Observable<T[K1]>`.\r\n     *\r\n     * @example\r\n     * // Access a single property\r\n     *\r\n     * const bar$ = state.select('bar');\r\n     *\r\n     * // Access a nested property\r\n     *\r\n     * const foo$ = state.select('bar', 'foo');\r\n     *\r\n     * @return Observable<T[K1]>\r\n     */\r\n    select<K1 extends keyof T>(k1: K1): Observable<T[K1]>;\r\n    /**\r\n     * @internal\r\n     */\r\n    select<K1 extends keyof T, K2 extends keyof T[K1]>(k1: K1, k2: K2): Observable<T[K1][K2]>;\r\n    /**\r\n     * @internal\r\n     */\r\n    select<K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2]>(k1: K1, k2: K2, k3: K3): Observable<T[K1][K2][K3]>;\r\n    /**\r\n     * @internal\r\n     */\r\n    select<K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2], K4 extends keyof T[K1][K2][K3]>(k1: K1, k2: K2, k3: K3, k4: K4): Observable<T[K1][K2][K3][K4]>;\r\n    /**\r\n     * @internal\r\n     */\r\n    select<K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2], K4 extends keyof T[K1][K2][K3], K5 extends keyof T[K1][K2][K3][K4]>(k1: K1, k2: K2, k3: K3, k4: K4, k5: K5): Observable<T[K1][K2][K3][K4][K5]>;\r\n    /**\r\n     * @internal\r\n     */\r\n    select<K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2], K4 extends keyof T[K1][K2][K3], K5 extends keyof T[K1][K2][K3][K4], K6 extends keyof T[K1][K2][K3][K4][K5]>(k1: K1, k2: K2, k3: K3, k4: K4, k5: K5, k6: K6): Observable<T[K1][K2][K3][K4][K5][K6]>;\r\n    /**\r\n     * @description\r\n     * Manages side-effects of your state. Provide an `Observable<any>` **side-effect** and an optional\r\n     * `sideEffectFunction`.\r\n     * Subscription handling is done automatically.\r\n     *\r\n     * @example\r\n     * // Directly pass an observable side-effect\r\n     * const localStorageEffect$ = changes$.pipe(\r\n     *  tap(changes => storeChanges(changes))\r\n     * );\r\n     * state.hold(localStorageEffect$);\r\n     *\r\n     * // Pass an additional `sideEffectFunction`\r\n     *\r\n     * const localStorageEffectFn = changes => storeChanges(changes);\r\n     * state.hold(changes$, localStorageEffectFn);\r\n     *\r\n     * @param {Observable<S>} obsOrObsWithSideEffect\r\n     * @param {function} [sideEffectFn]\r\n     */\r\n    hold<S>(obsOrObsWithSideEffect: Observable<S>, sideEffectFn?: (arg: S) => void): void;\r\n    /**\r\n     * @internal\r\n     */\r\n    subscribe(): Unsubscribable;\r\n}\r\nexport {};\r\n"]}
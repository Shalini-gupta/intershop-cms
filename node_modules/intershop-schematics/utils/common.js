"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateSelector = exports.findDeclaringModule = exports.detectExtension = exports.determineArtifactName = exports.applyNameAndPath = void 0;
const core_1 = require("@angular-devkit/core");
const find_module_1 = require("@schematics/angular/utility/find-module");
const parse_name_1 = require("@schematics/angular/utility/parse-name");
const validation_1 = require("@schematics/angular/utility/validation");
const workspace_1 = require("@schematics/angular/utility/workspace");
const selector_1 = require("./selector");
function applyNameAndPath(artifact, host, options) {
    return __awaiter(this, void 0, void 0, function* () {
        let path = options.path;
        let name = options.name;
        const workspace = yield (0, workspace_1.getWorkspace)(host);
        const project = workspace.projects.get(options.project);
        // remove possible added path from root
        if (name === null || name === void 0 ? void 0 : name.startsWith('src/app/')) {
            name = name.substr(8);
        }
        const parsedPath = (0, parse_name_1.parseName)(path || (0, workspace_1.buildDefaultPath)(project), name);
        name = parsedPath.name;
        if (artifact) {
            name = name.replace(new RegExp(`\-?${artifact}$`), '');
        }
        if (!options.restricted) {
            path = parsedPath.path;
        }
        if (options.artifactFolder) {
            // add artifact folder
            const containingFolder = `/${artifact}s`;
            if (!options.flat && !path.endsWith(containingFolder)) {
                path += containingFolder;
            }
        }
        (0, validation_1.validateName)(name);
        return Object.assign(Object.assign({}, options), { name,
            path });
    });
}
exports.applyNameAndPath = applyNameAndPath;
function determineArtifactName(artifact, _, options) {
    const kebab = core_1.strings.dasherize(options.name);
    let moduleImportPath;
    let artifactName;
    if (artifact === 'page') {
        moduleImportPath = `/${options.path}${kebab}/${kebab}-page.component`;
        artifactName = core_1.strings.classify(`${options.name}PageComponent`);
    }
    else {
        moduleImportPath = `/${options.path}${options.flat ? '' : `/${kebab}`}/${kebab}.${artifact}`;
        artifactName = core_1.strings.classify(`${options.name}-${artifact}`);
    }
    return Object.assign(Object.assign({}, options), { moduleImportPath,
        artifactName });
}
exports.determineArtifactName = determineArtifactName;
function detectExtension(artifact, host, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const workspace = yield (0, workspace_1.getWorkspace)(host);
        const project = workspace.projects.get(options.project);
        let extension = options.extension;
        const regex = /extensions\/([a-z][a-z0-9-]+)/;
        const requestDestination = (0, core_1.normalize)(`${options.path}/${options.name}`);
        if (regex.test(requestDestination)) {
            extension = requestDestination.match(regex)[1];
        }
        let path = options.path;
        if (options.restricted) {
            if (!extension) {
                let rootLocation;
                if (artifact === 'cms') {
                    rootLocation = 'shared/';
                }
                else if (['page', 'extension'].includes(artifact) || project.root) {
                    rootLocation = '';
                }
                else {
                    rootLocation = 'core/';
                }
                path = `${project.sourceRoot}/app/${rootLocation}${artifact.replace(/s$/, '')}s/`;
            }
            else {
                path = `${project.sourceRoot}/app/extensions/${extension}/${artifact}s/`;
            }
        }
        return Object.assign(Object.assign({}, options), { extension,
            path });
    });
}
exports.detectExtension = detectExtension;
function findDeclaringModule(host, options) {
    let module = (0, find_module_1.findModuleFromOptions)(host, Object.assign(Object.assign({}, options), { name: options.name }));
    const alternateModule = module.replace('.ts', '.all.ts');
    if (host.exists(alternateModule)) {
        module = alternateModule;
    }
    return Object.assign(Object.assign({}, options), { module });
}
exports.findDeclaringModule = findDeclaringModule;
function generateSelector(host, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const workspace = yield (0, workspace_1.getWorkspace)(host);
        const project = workspace.projects.get(options.project);
        const selector = options.selector || (0, selector_1.buildSelector)(options, project.prefix);
        (0, validation_1.validateHtmlSelector)(selector);
        return Object.assign(Object.assign({}, options), { selector });
    });
}
exports.generateSelector = generateSelector;

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setStyleUrls = exports.updateModule = exports.generateGitignore = exports.addDecoratorToClass = exports.addExportToBarrelFile = exports.addImportToFile = exports.addImportToNgModuleBefore = exports.insertExport = exports.insertImport = exports.addTokenProviderToNgModule = exports.addProviderToNgModule = exports.addDeclarationToNgModule = exports.addImportToNgModule = exports.addExportToNgModule = void 0;
const core_1 = require("@angular-devkit/core");
const tsquery_1 = require("@phenomnomnominal/tsquery");
const ast_utils_1 = require("@schematics/angular/utility/ast-utils");
const change_1 = require("@schematics/angular/utility/change");
const find_module_1 = require("@schematics/angular/utility/find-module");
const path = require("path");
const ts_morph_1 = require("ts-morph");
const tsutils_1 = require("tsutils");
const ts = require("typescript");
const filesystem_1 = require("./filesystem");
const ts_morph_2 = require("./ts-morph");
function addExportToNgModule(options) {
    return host => {
        const relativePath = (0, find_module_1.buildRelativePath)(options.module, options.moduleImportPath);
        const source = (0, filesystem_1.readIntoSourceFile)(host, options.module);
        const exportRecorder = host.beginUpdate(options.module);
        const exportChanges = (0, ast_utils_1.addExportToModule)(source, options.module, core_1.strings.classify(options.artifactName), relativePath);
        for (const change of exportChanges) {
            if (change instanceof change_1.InsertChange) {
                exportRecorder.insertLeft(change.pos, change.toAdd);
            }
        }
        host.commitUpdate(exportRecorder);
    };
}
exports.addExportToNgModule = addExportToNgModule;
function addImportToNgModule(options) {
    return host => {
        const relativePath = (0, find_module_1.buildRelativePath)(options.module, options.moduleImportPath);
        const source = (0, filesystem_1.readIntoSourceFile)(host, options.module);
        const importRecorder = host.beginUpdate(options.module);
        const importChanges = (0, ast_utils_1.addImportToModule)(source, options.module, core_1.strings.classify(options.artifactName), relativePath);
        for (const change of importChanges) {
            if (change instanceof change_1.InsertChange) {
                importRecorder.insertLeft(change.pos, change.toAdd);
            }
        }
        host.commitUpdate(importRecorder);
    };
}
exports.addImportToNgModule = addImportToNgModule;
function addDeclarationToNgModule(options) {
    return host => {
        const source = (0, filesystem_1.readIntoSourceFile)(host, options.module);
        const relativePath = (0, find_module_1.buildRelativePath)(options.module, options.moduleImportPath);
        const declarationChanges = (0, ast_utils_1.addDeclarationToModule)(source, options.module, options.artifactName, relativePath);
        const declarationRecorder = host.beginUpdate(options.module);
        for (const change of declarationChanges) {
            if (change instanceof change_1.InsertChange) {
                declarationRecorder.insertLeft(change.pos, change.toAdd);
            }
        }
        host.commitUpdate(declarationRecorder);
        return host;
    };
}
exports.addDeclarationToNgModule = addDeclarationToNgModule;
function addProviderToNgModule(options) {
    return host => {
        const source = (0, filesystem_1.readIntoSourceFile)(host, options.module);
        const relativePath = options.moduleImportPath
            ? (0, find_module_1.buildRelativePath)(options.module, options.moduleImportPath)
            : undefined;
        const declarationChanges = (0, ast_utils_1.addProviderToModule)(source, options.module, options.artifactName, relativePath);
        const declarationRecorder = host.beginUpdate(options.module);
        for (const change of declarationChanges) {
            if (change instanceof change_1.InsertChange) {
                declarationRecorder.insertLeft(change.pos, change.toAdd);
            }
        }
        host.commitUpdate(declarationRecorder);
        return host;
    };
}
exports.addProviderToNgModule = addProviderToNgModule;
function addTokenProviderToNgModule(options) {
    return host => {
        const tsMorphProject = (0, ts_morph_2.createTsMorphProject)(host);
        tsMorphProject.addSourceFileAtPath(options.module);
        const sourceFile = tsMorphProject.getSourceFile(options.module);
        sourceFile.getClasses()[0].getDecorator('NgModule').getArguments()[0]
            .getChildrenOfKind(ts_morph_1.SyntaxKind.PropertyAssignment)
            .find(child => child.getName() === 'providers')
            .getInitializerIfKindOrThrow(ts_morph_1.SyntaxKind.ArrayLiteralExpression)
            .addElement(`{ provide: ${options.token}, useClass: ${options.class}, multi: ${options.multi} }`);
        sourceFile
            .addImportDeclaration({
            moduleSpecifier: (0, find_module_1.buildRelativePath)(options.module, options.artifactPath),
        })
            .addNamedImport({ name: options.class });
        host.overwrite(options.module, sourceFile.getText());
        return host;
    };
}
exports.addTokenProviderToNgModule = addTokenProviderToNgModule;
function insertImport(source, recorder, artifactName, relativePath) {
    const imp = `import { ${artifactName} } from '${relativePath}';`;
    // insert import statement to imports
    const lastImportEnd = (0, tsutils_1.findImports)(source, tsutils_1.ImportKind.All)
        .map(x => x.parent.end)
        .sort((x, y) => x - y)
        .pop();
    if (lastImportEnd) {
        recorder.insertRight(lastImportEnd, `\n${imp}`);
    }
    else {
        recorder.insertLeft(0, `${imp}\n\n`);
    }
}
exports.insertImport = insertImport;
function insertExport(recorder, artifactName, relativePath) {
    const imp = `export { ${artifactName} } from '${relativePath}';`;
    recorder.insertLeft(0, `${imp}\n\n`);
}
exports.insertExport = insertExport;
function addImportToNgModuleBefore(options, beforeToken) {
    return host => {
        const relativePath = (0, find_module_1.buildRelativePath)(options.module, options.moduleImportPath);
        const source = (0, filesystem_1.readIntoSourceFile)(host, options.module);
        const importRecorder = host.beginUpdate(options.module);
        insertImport(source, importRecorder, options.artifactName, relativePath);
        let edited = false;
        (0, tsutils_1.forEachToken)(source, node => {
            if (node.kind === ts.SyntaxKind.Identifier &&
                node.getText() === beforeToken &&
                node.parent.kind === ts.SyntaxKind.ArrayLiteralExpression) {
                importRecorder.insertLeft(node.getStart(), `${options.artifactName}, `);
                edited = true;
            }
        });
        if (!edited) {
            throw new Error(`did not find '${beforeToken}' in ${options.module}`);
        }
        host.commitUpdate(importRecorder);
    };
}
exports.addImportToNgModuleBefore = addImportToNgModuleBefore;
function addImportToFile(options) {
    return host => {
        const relativePath = (0, find_module_1.buildRelativePath)(options.module, options.moduleImportPath);
        const source = (0, filesystem_1.readIntoSourceFile)(host, options.module);
        const importRecorder = host.beginUpdate(options.module);
        insertImport(source, importRecorder, options.artifactName, relativePath);
        host.commitUpdate(importRecorder);
    };
}
exports.addImportToFile = addImportToFile;
function addExportToBarrelFile(options) {
    const barrelFile = `/${options.path}/index.ts`;
    return host => {
        if (!(0, tsquery_1.tsquery)((0, filesystem_1.readIntoSourceFile)(host, barrelFile), `Identifier[name=${options.artifactName}]`).length) {
            const relativePath = (0, find_module_1.buildRelativePath)(barrelFile, options.moduleImportPath);
            const exportRecorder = host.beginUpdate(barrelFile);
            insertExport(exportRecorder, options.artifactName, relativePath);
            host.commitUpdate(exportRecorder);
        }
    };
}
exports.addExportToBarrelFile = addExportToBarrelFile;
function addDecoratorToClass(file, className, decoratorName, decoratorImport) {
    return host => {
        const source = (0, filesystem_1.readIntoSourceFile)(host, file);
        (0, tsquery_1.tsquery)(source, `ClassDeclaration:has(Identifier[name=${className}])`).forEach((classDeclaration) => {
            const exists = classDeclaration.decorators.find(decorator => (0, tsquery_1.tsquery)(decorator, 'Identifier').find(id => id.getText() === decoratorName));
            if (!exists) {
                const recorder = host.beginUpdate(file);
                const exportKeyword = (0, tsquery_1.tsquery)(source, `ClassDeclaration:has(Identifier[name=${className}]) > ExportKeyword`)[0];
                recorder.insertLeft(exportKeyword.getStart(), `@${decoratorName}()\n`);
                insertImport(source, recorder, decoratorName, decoratorImport);
                host.commitUpdate(recorder);
            }
        });
    };
}
exports.addDecoratorToClass = addDecoratorToClass;
function generateGitignore(options) {
    const gitignore = `/${options.path}/.gitignore`;
    return host => {
        host.create(gitignore, options.content);
        return host;
    };
}
exports.generateGitignore = generateGitignore;
function updateModule(options) {
    return host => {
        options.module = (0, find_module_1.findModule)(host, options.path);
        return host;
    };
}
exports.updateModule = updateModule;
function setStyleUrls(componentFile, styleUrls) {
    const normalizedStyleUrls = styleUrls.map(f => path.basename(f)).map(f => `./${f}`);
    const updateString = `[${normalizedStyleUrls.map(f => `'${f}'`).join(', ')}]`;
    return host => {
        const source = (0, filesystem_1.readIntoSourceFile)(host, componentFile);
        (0, tsquery_1.tsquery)(source, 'Decorator:has(Identifier[name=Component])').forEach((component) => {
            const callExpression = component.expression;
            const config = callExpression.arguments[0];
            const existingStyleUrls = config.properties.find(p => p.name.getText() === 'styleUrls');
            const recorder = host.beginUpdate(componentFile);
            if (existingStyleUrls) {
                recorder.remove(existingStyleUrls.initializer.getStart(), existingStyleUrls.initializer.getEnd() - existingStyleUrls.initializer.getStart());
                recorder.insertLeft(existingStyleUrls.initializer.getStart(), updateString);
            }
            else {
                const position = config.properties.reduce((max, curr) => (curr.getEnd() > max ? curr.getEnd() : max), 0);
                recorder.insertLeft(position, `, styleUrls: ${updateString}`);
            }
            host.commitUpdate(recorder);
        });
    };
}
exports.setStyleUrls = setStyleUrls;

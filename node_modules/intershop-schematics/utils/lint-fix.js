"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.applyLintFix = void 0;
const eslint_1 = require("eslint");
const fs_1 = require("fs");
const path_1 = require("path");
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const filesystem_1 = require("./filesystem");
function getRootESLintConfigPath() {
    const p = (0, path_1.normalize)(process.cwd());
    const segments = p.split(path_1.sep);
    let configPath = '';
    for (let i = segments.length; i > 0; i--) {
        const path = segments.slice(0, i).concat('.eslintrc.json').join(path_1.sep);
        if ((0, fs_1.existsSync)(path)) {
            configPath = path;
        }
    }
    return configPath;
}
function applyLintFix() {
    const eslint = new eslint_1.ESLint({ fix: true, overrideConfigFile: getRootESLintConfigPath() });
    return tree => {
        // Only include files that have been touched.
        const files = tree.actions
            .map(action => action.path.substring(1))
            .filter(path => path.endsWith('.ts') || path.endsWith('.html'))
            .filter((v, i, a) => a.indexOf(v) === i);
        if (files.length)
            return (0, rxjs_1.forkJoin)(files
                .map(filePath => ({ filePath, source: (0, filesystem_1.readIntoSourceFile)(tree, filePath) }))
                .map(({ source, filePath }) => (0, rxjs_1.from)(eslint.lintText(source.text, { filePath })).pipe((0, operators_1.tap)(results => {
                var _a;
                if ((_a = results[0]) === null || _a === void 0 ? void 0 : _a.output) {
                    tree.overwrite(filePath, results[0].output);
                }
            })))).pipe((0, operators_1.mapTo)(tree));
        else
            return tree;
    };
}
exports.applyLintFix = applyLintFix;

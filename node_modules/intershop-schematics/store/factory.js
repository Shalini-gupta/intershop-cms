"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createStore = exports.determineStoreLocation = void 0;
const core_1 = require("@angular-devkit/core");
const schematics_1 = require("@angular-devkit/schematics");
const workspace_1 = require("@schematics/angular/utility/workspace");
const tsutils_1 = require("tsutils");
const ts = require("typescript");
const common_1 = require("../utils/common");
const filesystem_1 = require("../utils/filesystem");
const lint_fix_1 = require("../utils/lint-fix");
const registration_1 = require("../utils/registration");
// eslint-disable-next-line complexity
function determineStoreLocation(host, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const workspace = yield (0, workspace_1.getWorkspace)(host);
        const project = workspace.projects.get(options.project);
        let extension = options.extension;
        const regex = /extensions\/([a-z][a-z0-9-]+)/;
        const requestDestination = (0, core_1.normalize)(`${options.path}/${options.name}`);
        if (regex.test(requestDestination)) {
            extension = requestDestination.match(regex)[1];
        }
        let feature = options.feature;
        if (!extension && !feature) {
            const nameWOStore = options.name.replace(/.*store\//, '');
            if (nameWOStore.includes('/')) {
                const pathFragments = nameWOStore.split('/');
                feature = pathFragments[pathFragments.length - 2];
            }
            else {
                feature = 'core';
            }
        }
        const projectName = project.root.replace(/^.*?\//g, '');
        let parent;
        let path = options.path;
        if (project.root) {
            parent = projectName;
            path = `${project.sourceRoot}/app/store/`;
        }
        else if (!extension && !feature) {
            path = `${project.sourceRoot}/app/core/store/core/`;
            parent = 'core';
        }
        else if (!extension && feature) {
            path = `${project.sourceRoot}/app/core/store/${feature}/`;
            parent = feature;
        }
        else if (extension && !feature) {
            path = `${project.sourceRoot}/app/extensions/${extension}/store/`;
            parent = extension;
        }
        else {
            throw new Error('cannot add feature store in extension');
        }
        const name = options.name.split('/').pop();
        if (projectName) {
            // override so it behaves like extension
            extension = projectName;
        }
        if (name === feature) {
            throw new Error('name of feature and store cannot be equal');
        }
        if (name === extension) {
            throw new Error('name of extension and store cannot be equal');
        }
        return Object.assign(Object.assign({}, options), { parentStorePath: `${path}${parent}`, name,
            extension,
            feature,
            path,
            parent });
    });
}
exports.determineStoreLocation = determineStoreLocation;
function registerStateInStore(options) {
    return host => {
        const artifactName = `${core_1.strings.classify(options.name)}State`;
        const file = (0, core_1.normalize)(`${options.parentStorePath}-store.ts`);
        const parentArtifact = `${core_1.strings.classify(options.parent)}State`;
        const source = (0, filesystem_1.readIntoSourceFile)(host, file);
        const update = host.beginUpdate(file);
        (0, tsutils_1.forEachToken)(source, node => {
            if (node.kind === ts.SyntaxKind.Identifier &&
                node.getText() === parentArtifact &&
                node.parent.kind === ts.SyntaxKind.InterfaceDeclaration) {
                const stateInterface = node.parent;
                const closingBrace = stateInterface.getChildren().filter(n => n.kind === ts.SyntaxKind.CloseBraceToken)[0];
                update.insertLeft(closingBrace.pos, `\n  ${core_1.strings.camelize(options.name)}: ${artifactName};`);
            }
        });
        const relativePath = `./${core_1.strings.dasherize(options.name)}/${core_1.strings.dasherize(options.name)}.reducer`;
        (0, registration_1.insertImport)(source, update, artifactName, relativePath);
        host.commitUpdate(update);
        return host;
    };
}
function registerReducerInStoreModule(options) {
    return host => {
        const artifactName = `${core_1.strings.camelize(options.name)}Reducer`;
        const file = `${options.parentStorePath}-store.module.ts`;
        const parentArtifact = `${core_1.strings.camelize(options.parent)}Reducers`;
        const source = (0, filesystem_1.readIntoSourceFile)(host, file);
        const update = host.beginUpdate(file);
        (0, tsutils_1.forEachToken)(source, node => {
            if (node.kind === ts.SyntaxKind.Identifier &&
                node.getText() === parentArtifact &&
                node.parent.kind === ts.SyntaxKind.VariableDeclaration) {
                const declaration = node.parent;
                const map = declaration.initializer;
                update.insertLeft(map.properties.end, `${map.properties.hasTrailingComma || map.properties.length === 0 ? '' : ','} ${core_1.strings.camelize(options.name)}: ${artifactName}`);
            }
        });
        const relativePath = `./${core_1.strings.dasherize(options.name)}/${core_1.strings.dasherize(options.name)}.reducer`;
        (0, registration_1.insertImport)(source, update, artifactName, relativePath);
        host.commitUpdate(update);
        return host;
    };
}
function registerEffectsInStoreModule(options) {
    return host => {
        const artifactName = `${core_1.strings.classify(options.name)}Effects`;
        const file = `${options.parentStorePath}-store.module.ts`;
        const parentArtifact = `${core_1.strings.camelize(options.parent)}Effects`;
        const source = (0, filesystem_1.readIntoSourceFile)(host, file);
        const update = host.beginUpdate(file);
        (0, tsutils_1.forEachToken)(source, node => {
            if (node.kind === ts.SyntaxKind.Identifier &&
                node.getText() === parentArtifact &&
                node.parent.kind === ts.SyntaxKind.VariableDeclaration) {
                const declaration = node.parent;
                const list = declaration.initializer;
                update.insertLeft(list.elements.end, `${list.elements.hasTrailingComma || list.elements.length === 0 ? '' : ','} ${artifactName}`);
            }
        });
        const relativePath = `./${core_1.strings.dasherize(options.name)}/${core_1.strings.dasherize(options.name)}.effects`;
        (0, registration_1.insertImport)(source, update, artifactName, relativePath);
        host.commitUpdate(update);
        return host;
    };
}
function createStore(options) {
    return (host) => __awaiter(this, void 0, void 0, function* () {
        if (!options.project) {
            throw new schematics_1.SchematicsException('Option (project) is required.');
        }
        options = yield determineStoreLocation(host, options);
        options = yield (0, common_1.applyNameAndPath)('store', host, options);
        options = (0, common_1.determineArtifactName)('store', host, options);
        const operations = [];
        operations.push((0, schematics_1.mergeWith)((0, schematics_1.apply)((0, schematics_1.url)('./files'), [
            (0, schematics_1.applyTemplates)(Object.assign(Object.assign({}, core_1.strings), options)),
            (0, schematics_1.move)(options.path),
        ])));
        operations.push(registerStateInStore(options));
        operations.push(registerEffectsInStoreModule(options));
        operations.push(registerReducerInStoreModule(options));
        operations.push((0, lint_fix_1.applyLintFix)());
        return (0, schematics_1.chain)(operations);
    });
}
exports.createStore = createStore;

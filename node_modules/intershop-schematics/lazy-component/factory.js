"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createLazyComponent = void 0;
const core_1 = require("@angular-devkit/core");
const schematics_1 = require("@angular-devkit/schematics");
const tsquery_1 = require("@phenomnomnominal/tsquery");
const workspace_1 = require("@schematics/angular/utility/workspace");
const ts = require("typescript");
const common_1 = require("../utils/common");
const lint_fix_1 = require("../utils/lint-fix");
const registration_1 = require("../utils/registration");
function createLazyComponent(options) {
    // eslint-disable-next-line complexity
    return (host) => __awaiter(this, void 0, void 0, function* () {
        if (!options.project) {
            throw new schematics_1.SchematicsException('Option (project) is required.');
        }
        const workspace = yield (0, workspace_1.getWorkspace)(host);
        const isProject = options.path.startsWith('projects/');
        const isShared = options.path.startsWith('src/app/shared/');
        const originalPath = options.path.replace(/.*src\/app\//, '');
        const extension = originalPath.split('/')[1];
        const declaringModule = isShared ? 'shared' : isProject ? options.path.split('/')[1] : extension;
        const project = workspace.projects.get(isProject ? options.path.split('/')[1] : options.project);
        const componentPath = `/${project.sourceRoot}/app/${originalPath}`;
        if (!originalPath.endsWith('component.ts') ||
            !(originalPath.startsWith('extensions/') || isProject || isShared) ||
            !host.exists(componentPath)) {
            throw new schematics_1.SchematicsException('path does not point to an existing component in an extension, project or shared module');
        }
        const originalName = /\/([a-z0-9-]+)\.component\.ts/.exec(originalPath)[1];
        options.name = `lazy-${originalName}`;
        if (isProject) {
            options.path = `${project.sourceRoot}/app/exports`;
        }
        else if (isShared) {
            options.path = `${project.sourceRoot}/app/shell/shared`;
        }
        else {
            options.path = `${project.sourceRoot}/app/extensions/${extension}/exports`;
        }
        options = (0, common_1.findDeclaringModule)(host, options);
        options = (0, common_1.determineArtifactName)('component', host, options);
        let bindings = [];
        let imports = [];
        const componentContent = host.read(componentPath).toString('utf-8');
        const componentSource = ts.createSourceFile(componentPath, componentContent, ts.ScriptTarget.Latest, true);
        const selectorPropertyAssignment = (0, tsquery_1.tsquery)(componentSource, 'CallExpression:has(Identifier[name=Component]) PropertyAssignment:has(Identifier[name=selector])')[0];
        options.selector = selectorPropertyAssignment.initializer
            .getText()
            .replace(/'/g, '')
            .replace(originalName.replace(`${project.prefix}-`, ''), options.name.replace(`${project.prefix}-`, ''));
        if (componentContent.includes('@Input(')) {
            const bindingNodes = (0, tsquery_1.tsquery)(componentSource, 'PropertyDeclaration:has(Decorator Identifier[text=Input])');
            bindings = bindingNodes.map(node => ({
                declaration: node.getText(),
                name: node.name.getText(),
            }));
            const importTypes = bindingNodes
                .map(node => (0, tsquery_1.tsquery)(node, 'TypeReference > Identifier').map(identifier => identifier.getText()))
                .reduce((acc, val) => acc.concat(...val), []);
            if (importTypes.length) {
                const importDeclarations = (0, tsquery_1.tsquery)(componentSource, 'ImportDeclaration');
                imports = importDeclarations
                    .map(decl => ({
                    from: decl.moduleSpecifier.getText(),
                    types: decl.importClause.namedBindings
                        ? (0, tsquery_1.tsquery)(decl.importClause.namedBindings, 'Identifier')
                            .map(n => n.getText())
                            .filter(importType => importTypes.includes(importType))
                        : [],
                }))
                    .filter(decl => decl.types.length);
            }
        }
        let onChanges;
        if (componentContent.includes('ngOnChanges')) {
            const ngOnChangesDeclaration = (0, tsquery_1.tsquery)(componentSource, 'MethodDeclaration:has(Identifier[name=ngOnChanges])')[0];
            if (ngOnChangesDeclaration) {
                if (ngOnChangesDeclaration.parameters.length) {
                    onChanges = 'complex';
                }
                else {
                    onChanges = 'simple';
                }
            }
        }
        const exportsModuleName = `${declaringModule}-exports`;
        const exportsModuleExists = host.exists(`/${options.path}/${exportsModuleName}.module.ts`);
        const gitignoreExists = host.exists(`/${options.path}/.gitignore`);
        let componentImportPath;
        if (isProject) {
            componentImportPath = '../../components';
        }
        else if (isShared) {
            const pathFragments = originalPath.split('/');
            pathFragments.pop();
            pathFragments.pop();
            componentImportPath = `../../../${pathFragments.join('/')}`;
        }
        else {
            componentImportPath = '../../shared';
        }
        const operations = [];
        if (!options.ci) {
            if (!isShared && !exportsModuleExists) {
                operations.push((0, schematics_1.schematic)('module', Object.assign(Object.assign({}, options), { name: exportsModuleName, flat: true })));
                operations.push((0, registration_1.updateModule)(options));
                operations.push((0, registration_1.addExportToBarrelFile)(Object.assign(Object.assign({}, options), { artifactName: core_1.strings.classify(`${exportsModuleName}-module`), moduleImportPath: `/${options.path}/${exportsModuleName}.module` })));
            }
            operations.push((0, registration_1.addDeclarationToNgModule)(options));
            if (!isShared) {
                operations.push((0, registration_1.addExportToNgModule)(options));
            }
            if (!gitignoreExists) {
                operations.push((0, registration_1.generateGitignore)(Object.assign(Object.assign({}, options), { content: '/lazy**' })));
            }
            if (isProject) {
                operations.push((0, registration_1.addExportToBarrelFile)(options));
            }
            operations.push((0, registration_1.addDecoratorToClass)(componentPath, core_1.strings.classify(`${originalName}Component`), 'GenerateLazyComponent', 'ish-core/utils/module-loader/generate-lazy-component.decorator'));
        }
        operations.push((0, schematics_1.mergeWith)((0, schematics_1.apply)((0, schematics_1.url)('./files'), [
            (0, schematics_1.applyTemplates)(Object.assign(Object.assign(Object.assign({}, core_1.strings), options), { bindings,
                imports,
                originalPath,
                extension,
                originalName,
                onChanges,
                isProject,
                isShared,
                componentImportPath,
                declaringModule })),
            (0, schematics_1.move)(options.path),
            (0, schematics_1.forEach)(fileEntry => {
                if (host.exists(fileEntry.path)) {
                    host.overwrite(fileEntry.path, fileEntry.content);
                    // eslint-disable-next-line unicorn/no-null
                    return null;
                }
                else {
                    return fileEntry;
                }
            }),
        ])));
        operations.push((0, lint_fix_1.applyLintFix)());
        return (0, schematics_1.chain)(operations);
    });
}
exports.createLazyComponent = createLazyComponent;

"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createPage = exports.addRouteToRoutingModule = void 0;
const core_1 = require("@angular-devkit/core");
const schematics_1 = require("@angular-devkit/schematics");
const workspace_1 = require("@schematics/angular/utility/workspace");
const tsutils_1 = require("tsutils");
const ts = require("typescript");
const common_1 = require("../utils/common");
const filesystem_1 = require("../utils/filesystem");
const lint_fix_1 = require("../utils/lint-fix");
const registration_1 = require("../utils/registration");
function addRouteToArray(options, host, position, insertComma) {
    const dasherizedName = core_1.strings.dasherize(options.name);
    const path = options.child ? options.child : options.lazy ? dasherizedName : dasherizedName.replace(/-/g, '/');
    if (options.lazy) {
        const loadChildren = `() => import('${options.child ? '..' : '.'}/${dasherizedName}/${dasherizedName}-page.module').then(m => m.${core_1.strings.classify(dasherizedName)}PageModule)`;
        const recorder = host.beginUpdate(options.routingModule);
        recorder.insertRight(position, `${insertComma ? ', ' : ''}{ path: '${path}', loadChildren: ${loadChildren} }`);
        host.commitUpdate(recorder);
    }
    else {
        const recorder = host.beginUpdate(options.routingModule);
        recorder.insertRight(position, `${insertComma ? ', ' : ''}{ path: '${path}', component: ${core_1.strings.classify(options.name)}PageComponent }`);
        host.commitUpdate(recorder);
    }
}
// eslint-disable-next-line complexity
function determineRoutingModule(host, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const workspace = yield (0, workspace_1.getWorkspace)(host);
        const project = workspace.projects.get(options.project);
        let routingModuleLocation;
        let child;
        let subPaging;
        const match = options.name.match(/(.*)\-([a-z0-9]+)/);
        if (options.lazy && match && match[1] && match[2]) {
            const parent = match[1];
            const possibleChild = match[2];
            routingModuleLocation = options.extension
                ? `extensions/${options.extension}/pages/${parent}/${parent}-page.module.ts`
                : `pages/${parent}/${parent}-page.module.ts`;
            subPaging = host.exists(`${project.sourceRoot}/app/${routingModuleLocation}`);
            if (subPaging) {
                child = possibleChild;
                console.log(`detected subpage, will insert '${child}' as sub page of '${parent}'`);
            }
        }
        if (!subPaging) {
            routingModuleLocation = options.extension
                ? `extensions/${options.extension}/pages/${options.extension}-routing.module.ts`
                : `${project.root ? `pages/${project.root.replace(/^.*?\//g, '')}` : 'pages/app'}-routing.module.ts`;
        }
        let routingModule = (0, core_1.normalize)(`${(0, workspace_1.buildDefaultPath)(project)}/${routingModuleLocation}`);
        const alternateModule = routingModule.replace('.ts', '.all.ts');
        if (host.exists(alternateModule)) {
            routingModule = alternateModule;
        }
        return Object.assign(Object.assign({}, options), { routingModule,
            child });
    });
}
function addRouteToRoutingModule(options) {
    return host => {
        const source = (0, filesystem_1.readIntoSourceFile)(host, options.routingModule);
        (0, tsutils_1.forEachToken)(source, node => {
            if (node.kind === ts.SyntaxKind.Identifier && /^[a-zA-Z0-9]*(R|r)outes$/.test(node.getText())) {
                const parent = node.parent;
                if (parent.kind === ts.SyntaxKind.VariableDeclaration) {
                    const routesArray = (0, tsutils_1.getChildOfKind)(parent, ts.SyntaxKind.ArrayLiteralExpression);
                    if (routesArray) {
                        const routes = (0, tsutils_1.getChildOfKind)(routesArray, ts.SyntaxKind.SyntaxList);
                        if (routes.getChildCount() > 0) {
                            const lastChild = routes.getChildren()[routes.getChildCount() - 1];
                            const insertComma = lastChild.kind !== ts.SyntaxKind.CommaToken;
                            addRouteToArray(options, host, lastChild.end, insertComma);
                        }
                        else {
                            addRouteToArray(options, host, routes.end, false);
                        }
                    }
                }
            }
        });
    };
}
exports.addRouteToRoutingModule = addRouteToRoutingModule;
function createPage(options) {
    return (host) => __awaiter(this, void 0, void 0, function* () {
        if (!options.project) {
            throw new schematics_1.SchematicsException('Option (project) is required.');
        }
        options = yield (0, common_1.detectExtension)('page', host, options);
        options = yield (0, common_1.applyNameAndPath)('page', host, options);
        options = (0, common_1.determineArtifactName)('page', host, options);
        options = yield determineRoutingModule(host, options);
        const operations = [];
        if (options.lazy) {
            operations.push((0, schematics_1.mergeWith)((0, schematics_1.apply)((0, schematics_1.url)('./files'), [
                (0, schematics_1.applyTemplates)(Object.assign(Object.assign({}, core_1.strings), options)),
                (0, schematics_1.move)(options.path),
            ])));
        }
        else {
            operations.push((0, registration_1.addImportToFile)(Object.assign(Object.assign({}, options), { module: options.routingModule })));
        }
        operations.push((0, schematics_1.schematic)('component', Object.assign(Object.assign({}, options), { name: `${options.name}-page`, path: `${options.path}${options.name}`, flat: true })));
        operations.push(addRouteToRoutingModule(options));
        operations.push((0, lint_fix_1.applyLintFix)());
        return (0, schematics_1.chain)(operations);
    });
}
exports.createPage = createPage;

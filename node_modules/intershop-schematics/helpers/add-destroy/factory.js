"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.add = void 0;
const schematics_1 = require("@angular-devkit/schematics");
const workspace_1 = require("@schematics/angular/utility/workspace");
const ts_morph_1 = require("ts-morph");
const lint_fix_1 = require("../../utils/lint-fix");
const ts_morph_2 = require("../../utils/ts-morph");
function add(options) {
    return (host) => __awaiter(this, void 0, void 0, function* () {
        if (!options.project) {
            throw new schematics_1.SchematicsException('Option (project) is required.');
        }
        const workspace = yield (0, workspace_1.getWorkspace)(host);
        const project = workspace.projects.get(options.project);
        let path = `${(0, workspace_1.buildDefaultPath)(project)}/${options.name.replace(/.*src\/app\//, '').replace(/\/$/, '')}`;
        if (!path.endsWith('.ts') && host.getDir(path)) {
            const file = host.getDir(path).subfiles.find(el => /(component|pipe|directive)\.ts/.test(el));
            path = `${path}/${file}`;
        }
        if (!path || !host.exists(path)) {
            throw new schematics_1.SchematicsException('Option (path) is required and must exist.');
        }
        const tsMorphProject = (0, ts_morph_2.createTsMorphProject)(host);
        tsMorphProject.addSourceFileAtPath(path);
        const sourceFile = tsMorphProject.getSourceFile(path);
        sourceFile
            .getClasses()
            .filter(clazz => clazz.isExported())
            .forEach(classDeclaration => {
            if (!classDeclaration.getImplements().find(imp => imp.getText() === 'OnDestroy')) {
                classDeclaration.addImplements('OnDestroy');
            }
            if (!classDeclaration.getProperty('destroy$')) {
                classDeclaration.insertProperty(classDeclaration.getProperties().length, {
                    name: 'destroy$',
                    initializer: 'new Subject<void>()',
                    scope: ts_morph_1.Scope.Private,
                });
            }
            if (!classDeclaration.getMethod('ngOnDestroy')) {
                const onDestroyMethod = classDeclaration.addMethod({
                    name: 'ngOnDestroy',
                });
                const methodBody = onDestroyMethod.addBody();
                methodBody.setBodyText(`this.destroy$.next();
this.destroy$.complete();`);
            }
        });
        const angularCoreImport = sourceFile.getImportDeclarationOrThrow(imp => imp.getModuleSpecifierValue() === '@angular/core');
        if (!angularCoreImport.getNamedImports().find(el => el.getText() === 'OnDestroy')) {
            angularCoreImport.addNamedImport('OnDestroy');
        }
        const rxjsImport = sourceFile.getImportDeclaration(imp => imp.getModuleSpecifierValue() === 'rxjs');
        if (!rxjsImport) {
            sourceFile.addImportDeclaration({
                namedImports: ['Subject'],
                moduleSpecifier: 'rxjs',
            });
        }
        else if (!rxjsImport.getNamedImports().find(el => el.getText() === 'Subject')) {
            rxjsImport.addNamedImport('Subject');
        }
        sourceFile.formatText({ indentSize: 2, convertTabsToSpaces: true });
        host.overwrite(path, sourceFile.getText());
        const operations = [];
        if (!options.ci) {
            operations.push((0, lint_fix_1.applyLintFix)());
        }
        return (0, schematics_1.chain)(operations);
    });
}
exports.add = add;

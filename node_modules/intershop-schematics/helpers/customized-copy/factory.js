"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.customize = void 0;
const core_1 = require("@angular-devkit/core");
const schematics_1 = require("@angular-devkit/schematics");
const tsquery_1 = require("@phenomnomnominal/tsquery");
const workspace_1 = require("@schematics/angular/utility/workspace");
const path_1 = require("path");
const common_1 = require("../../utils/common");
const filesystem_1 = require("../../utils/filesystem");
const lint_fix_1 = require("../../utils/lint-fix");
const registration_1 = require("../../utils/registration");
const factory_1 = require("../move-component/factory");
function customize(options) {
    return (host) => __awaiter(this, void 0, void 0, function* () {
        var _a;
        if (!options.project) {
            throw new schematics_1.SchematicsException('Option (project) is required.');
        }
        if (!options.from) {
            throw new schematics_1.SchematicsException('Option (from) is required.');
        }
        console.warn("DEPRECATION:\nUsing 'customized-copy' is deprecated and only still available for compatibility with older projects.\nNewer projects should use the 'override' schematic.");
        const workspace = yield (0, workspace_1.getWorkspace)(host);
        const project = workspace.projects.get(options.project);
        const sourceRoot = project.sourceRoot;
        const from = `${options.path ? `${options.path}/` : !((_a = options.from) === null || _a === void 0 ? void 0 : _a.startsWith(`${sourceRoot}/app/`)) ? `${sourceRoot}/app/` : ''}${options.from.replace(/\/$/, '')}`;
        const dir = host.getDir(from);
        const fromName = (0, path_1.basename)(dir.path);
        if (!dir || !dir.subfiles.length || !dir.subfiles.find(v => v.endsWith('component.ts'))) {
            throw new schematics_1.SchematicsException('Option (from) is not pointing to a component folder.');
        }
        dir.subfiles.forEach(file => {
            host.create((0, path_1.join)(dir.parent.path, `${project.prefix}-${fromName}`, `${project.prefix}-${file}`), host.read(dir.file(file).path));
        });
        const toName = `${project.prefix}-${fromName}`;
        host.visit(file => {
            if (file.startsWith(`/${sourceRoot}/app/`) && !file.includes(`/${fromName}/${fromName}.component`)) {
                if (file.includes(`/${project.prefix}-${fromName}/`) && file.endsWith('.component.ts')) {
                    (0, factory_1.updateComponentDecorator)(host, file, `ish-${fromName}`, fromName);
                    (0, factory_1.updateComponentDecorator)(host, file, fromName, toName);
                }
                if (file.endsWith('.ts')) {
                    (0, factory_1.updateComponentClassName)(host, file, `${core_1.strings.classify(fromName)}Component`, `${core_1.strings.classify(toName)}Component`);
                    const imports = (0, tsquery_1.tsquery)((0, filesystem_1.readIntoSourceFile)(host, file), file.includes(toName) ? `ImportDeclaration` : `ImportDeclaration[text=/.*${fromName}.*/]`).filter((x) => file.includes(fromName) || x.getText().includes(`/${fromName}/`));
                    if (imports.length) {
                        const updates = [];
                        imports.forEach(importDeclaration => {
                            (0, tsquery_1.tsquery)(importDeclaration, 'StringLiteral').forEach(node => {
                                const replacement = node
                                    .getFullText()
                                    .replace(new RegExp(`/${fromName}/${fromName}.component`), `/${toName}/${toName}.component`)
                                    .replace(new RegExp(`/${fromName}.component`), `/${toName}.component`);
                                if (node.getFullText() !== replacement) {
                                    updates.push({ node, replacement });
                                }
                            });
                        });
                        if (updates.length) {
                            const updater = host.beginUpdate(file);
                            updates.forEach(({ node, replacement }) => {
                                updater.remove(node.pos, node.end - node.pos).insertLeft(node.pos, replacement);
                            });
                            host.commitUpdate(updater);
                        }
                    }
                }
                (0, factory_1.updateComponentSelector)(host, file, fromName, `${project.prefix}-${fromName}`, false);
            }
        });
        let options2 = { name: from, project: options.project };
        options2 = yield (0, common_1.applyNameAndPath)('component', host, options2);
        options2 = (0, common_1.determineArtifactName)('component', host, options2);
        options2 = (0, common_1.findDeclaringModule)(host, options2);
        return (0, schematics_1.chain)([(0, registration_1.addDeclarationToNgModule)(options2), (0, lint_fix_1.applyLintFix)()]);
    });
}
exports.customize = customize;
